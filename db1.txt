
1 连接数据库服务器 （命令连接   图形工具）
]#mysql  -hlocalhost  -uroot  -p密码

]#grep  password  /var/log/mysqld.log                  //初始密码存放的地方
]#mysql -hlocalhost -uroot -p'k2T_SH0Jx%MB'

mysql> set global validate_password_policy=0; 
mysql> set global validate_password_length=6;
mysql> alter user root@"localhost" identified by "123456";    //用初始密码登上后进行改密码

mysql> quit
]#mysql -hlocalhost -uroot -p123456
mysql> show databases;
mysql> create database db1;


create table t2(
level tinyint
);

insert into t2 values(200);

select * from t2;


create table t3(
level tinyint unsigned
);

//无符号整型 unsigned

insert into t3 values(255);


create table t4(
pay double(5,2)
);

insert into t4 values(888.88);

select * from t4;

create table t5(
pay double(5,2) unsigned
);

create table t1(
name char
);
insert into t1 values("s");


create table t6(
name varchar(1)
);

insert into t6 values("s");

drop table t1;

delete from t1;

show databases;

show tables;

select  database();

use db1;

desc t5;


create table t6(
name char(15),
mail varchar(30)
);

insert into t6 values("bob","bob@163.com"),("xix","xix@163.com");


create table t7(
name char(15),
age  tinyint unsigned,
pay  float(7,2),
sex  enum("boy","girl","no"),
likes  set("eat","woman","game","money")
);

insert into t7 values("bob",17,5000,"boy","woman");

insert into t7 values("lal",21,5000,"boy","woman,money");

insert into t7 values("lal",21,5000,1,"woman,money");


create table t8(
name char(15),
syear  year,
birthday  date,
up_class  time,
party  datetime
);

insert into t8 values("dingding",1990,20180506,083000,20180618210000);




create table dog(
name char(6),
age  tinyint unsigned,
size enum("24","36"),
likes set("sex","lal","money","en")
);

insert into dog values("lili",23,"36","sex,money");


select now();                   //取当前系统的年月日时分秒
select date( now() );	        //取当前系统的年月日
select time( now() );
select month( now() );
select day( now() );
select time( now() );
select year( now() );
select year(20170506);        //取当前时间的年


insert into t8 values("la",year(19970506),date(now()),083000,now());

create table t9(
name char(5),
meeting  datetime,     //不输入值的话为 null
party  timestamp       //不输入值的话为 当前系统时间
);

insert into t9(name,meeting) values("luxi",now());

insert into t9(name,party) values("dada",20170506225530);

create  table t10(
name char(5),
level int(3) zerofill,
money int(5) zerofill
);

insert into t10 values("jqk",23,88);

insert into t10 values("bj",852,53545);

insert into t10 values("ex",333333,344344);


create table t11(
name char(5)  not null ,
level int(3) zerofill default 0,
money int(5)  zerofill default 0
);

insert into t11(name)  values("dfh");


alter table t10
add email char(30) default "stu@taren.com",
add  tel  char(11);

alter table t10
add sex enum("boy","girl","no")  default "no"
after name;

alter table t10
add stu_id char(9) first;

alter table t10 
modify  name char(10);


alter table t10
modify tel char(11)  after name;


alter table t10
drop sex,drop email;

alter table t10
change name NAME  char(10) ;


alter table t10
rename   stuinfo;

/////////////////
create table t12(
name char(5),
class char(7),
index (name),
index (class)
);

show index  from  t12\G;

drop index class on t12;

create	 index class on t12(class);


create table t17(
stu_id  char(9) primary key,    //主键不能为 null， 不能重复。
name  char(5)
);

insert into t17 values("180301","bob");

create table t17(
stu_id  char(9),
name  char(5),
primary key(stu_id)          //两种创建方法
);


alter table t17 
drop primary key;

alter table t17
add primary key(stu_id);


create table t18(
cip char(15),
serverport  smallint(2),
status enum("yes","no"),
primary key(cip,serverport)      //复合主键    两列之间不能同时重复
);

insert into t18 values("1.1.1.1",25,"yes");

alter table t18
drop primary key;       //删除复合主键   只能这样删除

alter table t18
add primary key(cip,serverport);        //在已有的表中添加复合主键，且表记录满足复合主键的要求


create table t19(
stu_id  int(2)  primary  key  auto_increment,    //自增长  必须是主键且为数值
name char(10),
age tinyint(2)
);

insert into t19(name,age) values("bab",23);

///移除主键前,如果有自增属性,必须先去掉

alter table t19
add id int(2) primary key  auto_increment  first;

外键

什么是外键?
让当前表字段的值在另一个表中字段值的范围内选择
  使用外键的条件
表的存储引擎必须是 innodb
字段类型要一致
被参照字段必须要是索引类型的一种 (primary key)

create table gzb(
gz_id int(2), 
name char(5),
bumen char(20),
pay float(7,2),
foreign key(gz_id) references ygb(yg_id)  on update cascade  on delete cascade);  

gzb(gz_id)表参照ygb(yg_id)  同步更新，同步删除


insert into gzb values ("2","tom","tea",25500);

update ygb set yg_id=8 where name="bob";


delete from ygb where yg_id=2;

alter table gzb add primary key(gz_id);

当一个表被当作参考的时候是不能被删除的，要把作外键的表中的外键删掉

alter table gzb drop foreign key gzb_ibfk_1 ;



数据导入导出
查看默认使用目录及目录是否存在   show variables like "secure_file_priv";

修改默认使用目录 
 vim /etc/my.cnf
....
 secure_file_priv=/dirdata

chown  mysql  /dirdata    修改权限

重启服务



导入要有相应的空表

create table user(
name char(30),
password  char(1),
uid  smallint(2),
gid  smallint(2),
comment char(100),
homedir char(150),
shell  char(50),
index(name)
);

若要在mysql中执行系统命令 （不需要加分号）   如： system  cp /etc/passwd  /var/lib/mysql-files/

导入数据

• 基本用法
LOAD DATA INFILE “ 目录名 / 文件名”
INTO TABLE 表名
FIELDS TERMINATED BY “ 分隔符”
LINES TERMINATED BY “\n”;
• 注意事项
– 字段分隔符要与文件内的一致
– 指定导入文件的绝对路径
– 导入数据的表字段类型要与文件字段匹配
– 禁用 SElinux



load data infile "/var/lib/mysql-files/passwd" into  table user fields terminated  by ":" lines terminated by "\n";

添加id表子段

alter table user 
add id int(2) primary key auto_increment first;

数据导出

基本用法
– SELECT 查询 .. ..
INTO OUTFILE “ 目录名 / 文件名”
FIELDS TERMINATED BY “ 分隔符”
LINES TERMINATED BY “\n”;
• 注意事项
– 导出的内容由 SQL 查询语句决定
– 禁用 SElinux

目录名为 mysql默认的那个（若修改过则以修改后的为准）


select * from user into outfile "/var/lib/mysql-files/user1.txt" ;

select name,id,password from user where id <= 3 into outfile "/var/lib/mysql-files/user3.txt" ;
导出 name  id  password 子段的前三行 

select name,id,password from user where id >=3 into outfile "/var/lib/mysql-files/user4.txt" fields terminated by "###"  lines terminated by "***";


管理表记录（增删改查）

insert into  user（表名）  values(....),(...);    如果要写多条记录用逗号隔开。

insert into  user(name,id)  values (...),();      给指定子段添加记录。

delete from user;     删除表中所有内容

delete  from  user  where name="bob"  加条件的删除

update  user set password=A;   修改表记录  如果要修改多个子段，用逗号隔开  (批量修改所有password子段)

update  user  set  password="A"  where id =40; 

select  * from user ;   查找表中的所有内容。

select  user,name  from user;  查找表中 user name  子段的内容

select  * from user where  user="bob" and id=2;   查找表中id为2且name为"bob"子段。

 


select * from user where uid < 3;

select * from user where uid < gid; 

where 子段名  符号  指

where 字段名  符号  字段名


数值比较
> >= < <= = !=

匹配空   is null
匹配非空  is  not  null

select name  from user  where uid is null;

insert into user(name)  values("yy");

update user set uid=4008 where uid is null;


select * from user where id = 3;

update user set gid = null  where id = 3 ;

逻辑比较

逻辑与   and    逻辑或  or   逻辑非  !   not   提高优先级 ()

select * from user where  name="root" and uid=0  and shell="/bin/bash";

select * from user where name="root"  or uid=0 or shell="/sbin/nologin";

select name,uid from user  where  name="root" and uid=1 or uid=3; 

select name,uid from user  where  name="root" and (uid=1 or uid=3); 

select name,uid from user  where  name="root" and (uid=0 or uid=3); 



匹配范围内的值

in （） 在...里    not in ()  不再这。。。里    between 10 and 20 在 10和20 之间   distinct  去重显示(重复的显示一次)

select name  from user  where name in ("apache","mysql","adm","bin");

select name  from user  where name  not in ("apache","mysql","adm","bin");

select name,uid from user  where  uid between 10 and 20;


select  distinct  shell from user ;

select distinct shell  from user where uid <= 10; 


模糊匹配

通配符 _  匹配单个字符   % 匹配 0～N 个字符

select  name from user where name like '___';

查找名字是三个字符的

select  name from user where name like '___' and uid >=10;    查找名字是三个字符的,且uid>=10

select name,uid from user where name like '__%__';  匹配名字不少于4个字符的

select  name from user where name like '%' ;   匹配名字多个字符的（但是查不到 null的, null 是没有数据，可以匹配到 空""）


正则匹配   regexp  ^ $ . * []...

select name,uid from user where uid regexp '^....$';  查看uid 是四个字符的

select name,uid from user where name regexp '^[0-9]';  查看以数字开头的

select name,uid from user where name regexp '[0-9]$';  查看以数字结尾的

select name,uid from user where name  regexp '[0-9]';    查看那包含数字的

运算操作
– 字段必须是数值类型
 +  -  *  /  % 

alter table user add age tinyint(2) unsigned  default 18  after name;

select name,age, 2018 - age syear from user  where name="root";

update user set age=age+1;

select name,uid,gid,(uid+gid)/2  pjz from user where uid >= 10 and uid <=20;


聚集函数
• MySQL 内置数据统计函数
– avg( 字段名 ) : 求平均值
– sum( 字段名 ) :求和
– min( 字段名 ) : 统计最小值
– max( 字段名 ) :统计最大值
– count( 字段名 ) :统计个数

可以加where 条件

select avg(uid) from user ;

select sum(uid) from user ;

select min(uid) from user ;

select max(uid) from user ;

select count(uid) from user ;


select count(*) from user ; 统计所有列的个数，以最大的为显示结果 

select count(uid),count(gid) from user ;  分别显示每一列的



操作查询结果


查询结果排序
• 基本用法
SQL 查询
ORDER BY 字段名
[ asc | desc ]

默认是升序   desc 是 降序

select name,uid  from user  where uid>=10 and uid<=20  order by uid desc;   查询结果以uid降序显示

查询结果分组
• 基本用法
– SQL 查询
group by 字段名

select  shell from user  group by shell;    （效果和查重复相似）

查询结果过滤
• 基本用法
– SQL 查询 having 条件表达式;
– SQL 查询 where 条件 having 条件表达式;
– SQL 查询 group by 字段名

HAVING 条件表达式;

select name from user  having name="root";

select shell from user  where uid>=10 and uid<=1000 group by shell  having shell="sync";

select id,name from user where name like '%' having name is null;    查看名字字段中有没有空的




限制查询结果显示行数


• 基本用法
– SQL 查询 limit n; 显示查询结果前 n 条记录
– SQL 查询 limit n,m ;显示指定范围内的查询记录

– SQL 查询 where 条件查询 limit n ;显示查询结果前 n 条记录
– SQL 查询 where 条件查询 limit n , n ;显示指定范围内的查询记录


select name from user limit 3;      显示前三行

select  name  from user limit 3,3;    从第四行开始显示，显示三行



MySQL 存储引擎


列出可用的存储引擎类型
– show engines; 或 show engines\g


修改默认存储引擎

[root@dbsvr1 ~]# vim /etc/my.cnf
[mysqld]
.. ..
default-storage-engine=MyISAM

重启服务


create database db2 ;

create table t1(
id int);

show create  table t1;


create table t2(
name char
)engine=innodb;

show create  table t2;


alter table t2 engine=innodb;     修改表的存储引擎

常用的存储引擎是 Myisam  innodb

myisam特点
一个表使用3个文件存储
t1.frm  t1.MYD  t1.MYI
表结构   数据    索引
不支持外键  和事务 和事务回滚
支持表级锁 （给一张表加锁）


innodb特点：
一个表使用2个文件存储
t2.frm   t2.ibd
表结构   数据+索引
支持外键  和事务 和事务回滚
支持行级锁 （只给被访问的行加锁）


事务： 一次sql操作从开始到结束的过程。

事务回滚： 在事务执行过程中任意一步操作失败，恢复所有的操作。

如：

ATM 
插卡  输入密码 登录成功

转账   对方卡号 8888888888
       转账金额 5W
       转账中.....  
		成功 -5w
                     +5w

                失败 -5w -- > +5w
                      事务回滚
退卡


事务能否回滚取决于事务日志文件，如果sql命令没有被提交，就可以回滚，如果已经提交就不能回滚

事务日志文件
ibdata1 未提交的sql
        LSN  日志序列号

ib_logfile0 已经提交的SQL
ib_logfile1


mysql> set autocommit = off;    关闭自动提交



锁 ： 解决并发访问冲突问题

锁粒度：行锁  表锁  页级锁（1M相当于1M）

锁类型：
select  读锁（共享锁）      大家还可以查询
pc1  select  * from t1; 
pc2  select  * from t1;
 
insert  update  delete

写锁（排它锁 或互斥锁）     有一个人在操作，其他人就无法操作
pc1  
update   t1 set name="bob" where 

name="root";

pc2 
update   t1 set name="bob2" where 

name="root";

执行查询操作多的表 适合使用myisam存储引擎，这样可以节省系统资源  (表级锁)

执行写操作多的表 适合使用innodb存储引擎，这样加大并发访问量。（行级锁）

MySQL 锁机制

查看当前的锁状态
– 检查 Table_lock 开头的变量, % 作通配符

show status like 'Table_lock%';

123

事务特性 (ACID)
• Atomic :原子性
– 事务的整个操作是一个整体,不可分割,要么全部成功,要么全部失败。
• Consistency : 一致性
– 事务操作的前后,表中的记录没有变化。
• Isolation :隔离性
– 事务操作是相互隔离不受影响的。
• Durability :持久性
– 数据一旦提交,不可改变,永久改变表数据


事务特性 (ACID) (续 1 )
• 示例

mysql> show variables like "autocommit"; // 查看提交状态
mysql> set autocommit=off; // 关闭自动提交
mysql> rollback ; // 数据回滚
mysql> commit; // 提交数据



复制表 (备份)    复制的时候表中的key 和索引是不能复制过来的，需要自己后期需要加

create database db4;

create table db4.t1  select * from db1.user;     把整张表备份一下

create table db4.t2  select id,name  from db1.user;   把id，name，字段备份

create tbale db4.t3 select * from db1.user  where  1=2;    查找不存在的内容 ，表中的记录是没有的，表字段是有的



  嵌套查询

内层查询的结果 作为外层查询的条件
select name,uid from db1.user where uid > (select avg(uid) from db1.user);  uid > 平均值的输出  同一个表中的查找	

select name from db4.t1 where name in (select user from mysql.user where host="localhost");   不同表中的查找   

多表查询（交叉查询）  笛卡尔集    

create table db4.t5 select name,uid,shell from db1.user limit 3;

create table  db4.t6 select name,uid,gid,homedir from db1.user limit 5;


select * from t5,t6;     查询t5,t6表中的所有记录

select * from t5,t6 where t5.uid = t6.uid;     查询t5.uid = t6.uid 的记录

select t5.shell,t6.* from t5,t6 where t5.uid = t6.uid;     查询t5.uid = t6.uid 的记录 只显示 t5.shell,t6.*的字段

左连接，当条件成立是以左表为主显示查询结果

– select 字段名列表  from  表1  left join 表2 on 条件表达式;

右连接，当条件成立是以右表为主显示查询结果

– select 字段名列表  from  表1  right join 表2 on 条件表达式;

create table t7 select name,uid,shell from db1.user limit 5;

create table t8 select name,uid,shell from db1.user limit 8;

select * from t7 left join t8 on t7.uid=t8.uid;      左连接  以左表t7显示为主

select * from t7 right join t8 on t7.uid=t8.uid;    左连接  以左表t8显示为主   



select * from t8 left join t7 on t7.uid=t8.uid;   







恢复 MySQL 管理员密码

[root@localhost ~]# vim /etc/my.cnf
[mysqld]
......
skip-grant-tables

::wq

[root@localhost ~]# systemctl restart mysqld

[root@localhost ~]# mysql

[mysql> update mysql.user set authentication_string=password("888888") where user="root" and host="localhost";

mysql> flush privileges;

mysql> quit

更改管理员密码  （只有系统管理员可以执行）

mysqladmin   -hlocalhost -uroot -p password 'abc123'
Enter password:  老密码






授权

with grant option 支持给其他用户授权

grant all on *.*  to amdin@"192.168.4.51" identified by '123456' with grant option;

mysql -h192.168.4.50 -uamdin -p123456

mysql> select  @@hostname;   显示连接mysql服务器的主机名

mysql> select  user; 显示哪个用户登陆的

mysql> show grants；  显示权限 

grant all on webdb.* to webuser@"192.168.4.%" identified by '123456';

grant select,update(name,uid) on db1.user to yaya@"%" identified by '123456';  授权yaya用户可以从任何ip登陆（可以ping的通）对db1.user有查询，和更新 name,uid 字段的权限。



mysql 中的user表         //存放用户，和登陆主机

查看当前mysql服务器中的用户，登陆主机，和用户的权限

select user,host from mysql.user;
show grants for yaya;

select user from mysql.user;
select * from mysql.user where user="admin"\G;


mysql 中的db表      //存放对库的操作权限


select * from mysql.db where db="webdb"\G;



mysql 中的mysql.tables_priv表     //存放对表的操作权限

 select host,user,db,table_name from mysql.tables_priv;

select * from mysql.tables_priv  where user="yaya"\G;


 
修改用户权限

select * from mysql.tables_priv  where user="yaya"\G;   查看yaya对哪个表有什么权限

update  mysql.tables_priv  set  Table_priv="select,insert" where user="yaya";    给yaya添加insert 权限

mysql> flush privileges;


撤销用户权限
撤销已有的权限，但是不影响用户登陆。

基本用法

 revoke 权限列表 on 库名 . 表名
 from 用户名 @' 客户端地址 ';

revoke GRANT OPTION on *.* from 'amdin'@'192.168.4.51';        撤销授权权限

revoke delete  on *.* from 'amdin'@'192.168.4.51';            撤销delete 权限


删除用户

drop user 'amdin'@'192.168.4.51';


重设用户密码

set password=password('123456');

管理员重设其他用户的密码

set password  for 'amdin'@'192.168.4.51'=password('112255');


数据库的备份与恢复



day05数据备份与恢复
一数据备份相关概念
1.1 数据备份的目的？  数据被误删除 或 设备损害导致数据丢失 ，是备份文件恢复数据。
1.2数据备份方式？
物理备份： 指定备份库和表对应的文件
51
cp   -r   /var/lib/mysql   /opt/mysql.bak      //拷贝整个数据库
cp  -r  /var/lib/mysql/bbsdb   /opt/bbsdb.bak     //拷贝单个库

rm -rf  /var/lib/mysql/bbsdb
cp   -r  /opt/bbsdb.bak    /var/lib/mysql/bbsdb             //恢复单个库     
chown  -R  mysql:mysql   /var/lib/mysql/bbsdb              //由于是系统管理员进行的拷贝，所有要把文件的所属关系，设置成mysql，否则没有权限
systemctl  restart  mysqld


51  scp  /opt/mysql.bak   192.168.4.51:/root/              //也可以把这台服务器上的mysql拷贝的文件，拿到另一台服务器上进行恢复，

52  rm  -rf /var/lib/mysql
      cp   -r  /root/mysql.bak   /var/lib/mysql
      chown  -R  mysql:mysql   /var/lib/mysql
      systemctl  restart  mysqld

逻辑备份： 在执行备份命令时，根据备份的库表及数据生成对应的sql命令，把sql存储到指定的文件里。


1.3数据备份策略？
完全备份  备份所有数据（一张表的所有数据  一个库的所有数据  一台数据库的所有数据）

备份新产生数据（差异备份 和 增量备份  都备份新产生的数据 ）
差异备份 备份自完全备份后，所有新产生的数据。
增量备份 备份自上次备份后，所有新产生的数据。

1.4工作中如何对数据做备份？
1.4.1  选择备份策略：
                             完全备份+差异备份
                             完全备份+增量备份
1.4.2  数据备份时间    数据服务器访问量少的时候执行备份
1.4.3  数据备份频率    根据数据产生量，决定备份频率
1.4.4 备份文件的命名   库名-日期.sql
1.4.5 备份文件的存储设置  准备独立的存储设备存储备份文件
1.4.6 如何执行备份  使用周期性计划任务执行本机脚本


完全备份+差异备份
                 06:00      t1	文件名        数据
1   完全                    10  1.sql	         10
2   差异                    3		2.sql	          3
3                           5   3.sql           8
4		                        2 	4.sql	         10
5		                        7	  5.sql	         17
6                       		4	  6.sql	         21
7 差异                      1	  7.sql	         22    	

完全备份+增量备份
                06:00      t1	文件名        数据
1   完全                    10               1.sql	 10
2   增量                    3		2.sql	 3
3                              5	3.sql           5
4		2	4.sql	 2
5		7	5.sql	7
6		4	6.sql	4
7  增量                         1	7.sql	1  
+++++++++++++++++++++++++++++
二完全备份与完全恢复
2.1 完全备份数据
利用mysqldump进行数据库的导入导出（进行数据的备份和恢复）

]# mkdir  -p /mydatabak
]# mysqldump -uroot -p654321  studb > /mydatabak/studb.sql       //把studb库导出到studb.sql       
]# mysqldump -uroot -p654321  db3 user3 > /mydatabak/db3-user3.sql

]#cat /mydatabak/studb.sql
]#cat  /mydatabak/db3-user3.sql

2.3 完全恢复数据
]# mysql -uroot -p654321  studb  < /mydatabak/studb.sql            数据的导入
]# mysql -uroot -p654321  db3   < /mydatabak/db3-user3.sql

使用source 命令恢复数据
mysql> create database  bbsdb;
mysql> use bbsdb;
mysql> source  /mydatabak/studb.sql


每周一晚上18:00备份studb库的所有数据到本机的/dbbak目录下，备份文件名称要求如下  日期_库名.sql。

]#vim /root/bakstudb.sh
#!/bin/bash
day=`date +%F`
if [ ! -e /dbbak  ];then
     mkdir /dbbak
fi
mysqldump  -uroot  -p654321  studb  >  /dbbak/${day}_studb.sql
:wq
]# chmod   +x   /root/bakstudb.sh
]#/root/bakstudb.sh
]# ls /dbbak/*.sql

]#crontab  -e
00  18   *  *  1        /root/bakstudb.sh  &> /dev/null
:wq


3.1  启动mysql数据库服务的binlog日志文件 实现实时增量备份
3.1.1 binlog日志介绍：是mysql数据库服务日志文件的一种，默认没有启用。记录除查询之外的sql命令。
查询命令例如： select   show   desc  
写命令例如： insert   update   delete   create  drop 

3.1.2 启用binlog日志
]#vim /etc/my.cnf
[mysqld]
server_id=51
log-bin
binlog-format="mixed"
:wq
]# systemctl  restart  mysqld

]# ls /var/lib/mysql/主机名-bin.000001
]# cat  /var/lib/mysql/主机名-bin.index

3.1.3 查看binlog日志文件内容
]#mysqlbinlog   /var/lib/mysql/mysql51-bin.000001

****可以自定义binlog日志文件存储的位置和文件名称
]#mkdir  /mylog
]#chown   mysql   /mylog
]#setenforce  0 

]#vim /etc/my.cnf
[mysqld]
server_id=51
#log-bin
log-bin=/mylog/plj
binlog-format="mixed"
:wq

]# systemctl  restart  mysqld
]#ls /mylog/plj.*
plj.000001   plj.index

3.1.4 手动生成新的日志文件方法
*默认日志文件大于500M时自动创建新日志文件

]# systemctl  restart mysqld

mysql> flush logs;

]# mysql -uroot -p密码 -e "flush logs"

]# mysqldump  -uroot -p密码  --flush-logs  库名  > 目录/xx.sql

使用一个新的日志文件 记录 新创建的webdb库的初始操作。
mysql> flush  logs;
mysql> create database webdb; create table webdb.a(id int);
mysql> insert into webdb.a values(100);
mysql> insert into webdb.a values(101);
mysql> flush logs;
删除webdb库，使用 binlog日志文件恢复webdb库的数据。
mysql>  drop   database  webdb;

3.1.7 使用binlog日志恢复数据
]#mysqlbinlog  /mylog/plj.000008   |  mysql  -uroot  -p654321 

3.1.5 删除已有的binlog日志文件

mysql> purge  master  logs  to  "binlog文件名; 
             删除指定日志文件之前的日志文件
mysql> purge  master  logs  to  "plj.000005";

mysql>  reset master ;  删除所有的日志文件重新生成第一个日志文件
mysql> show master status;  显示当前正在使用的binlog日志信息

]#mysqlbinlog   日志文件名；

3.1.6 binlog日志记录sql命令方式
记录方式有2种：  偏移量   、记录sql命令执行的时间

指定偏移量范围选项 
--start-position=偏移量的值  
--stop-position=偏移量的值

指定时间范围选项
--start-datetime="yyyy-mm-dd  hh:mm:ss"  
--stop-position="yyyy-mm-dd  hh:mm:ss" 
 ++++++++++++++++++++++++
读取日志文件指定范围内的sql命令恢复数据。
]# mysqlbinlog  --start-position=293  --stop-position=1450   plj.000001   |  mysql  -uroot  -

p654321
++++++++++++++++++++++++++++

]#mysqldump  -uroot  -p654321  --flush-logs  db3.user3  >  /root/user3.sql

mysql> insert into db3.user3 values("a","b","c");
mysql> insert into db3.user3 values("aa","b","c");
mysql> insert into db3.user3 values("ab","b","c");
mysql> insert into db3.user3 values("ac","b","c");

mysql> delete from  db3.users;
mysql> select  * from  db3.user3;

]#mysql  -uroot  -p654321  db3  <  /root/user3.sql
mysql> select  * from  db3.user3;

]#mysqlbinlog    --start-position=偏移量的值  
--stop-position=偏移量的值  日志文件名 |  mysql  -uroot  -p654321 

mysql> select  * from  db3.user3;
+++++++++++++++++++++++++++++++++
3.2  安装第3方软件提供备份命令，对数据做增量备份
软件介绍 Percona 开源软件  在线热备不锁表  适用于生成环境。

安装软件
]# rpm -ivh  libev-4.15-1.el6.rf.x86_64.rpm
]# yum -y  install   perl-DBD-mysql   perl-Digest-MD5
]# rpm  -ivh  percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm
]# rpm  -ql  percona-xtrabackup-24

提供2个备份命令
/usr/bin/innobackupex命令集成了命令xtrabackup，所以可以支持MYISAM存储引擎

/usr/bin/xtrabackup命令仅支持InnoDB和XtraDB存储引擎的表

innobackupex备份命令的使用格式？
]#innobackupex  <选项>
]# man  innobackupex

常用选项？
--user  用户名
--password  密码
--databases="库名"     
                     "库名1  库名2"
                     "库名.表名"
--no-timestamp  不使用时间戳做备份文件的子目录名

+++++++++++++++innobackupex完全备份 与 完全恢复
]# innobackupex  --user  root   --password   654321  \
--databases="mysql   performance_schema  sys   gamedb"   /allbak  --no-timestamp

++++++++++++++完全恢复   
--copy-back

]# rm   -rf  /var/lib/mysql
]# mkdir  /var/lib/mysql
]# innobackupex  --user root --password 654321  --copy-back  /allbak 
]# chown  -R  mysql:mysql  /var/lib/mysql
]#  systemctl  restart  mysqld
]#mysql   -uroot  -p654321
mysql> show  databases;
mysql> select  * from  gmaedb.t1;

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
事务日志文件
LSN    日志序列号


增量备份的工作过程？
每一个备份目录下，都有记录当前目录备份信息的配置文件
]# cat   备份目录名/xtrabackup_checkpoints   (记录备份类型 和lsn范围)


+++++++++innobackupex增量备份与恢复
--incremental  目录名                   #增量备份
--incremental-basedir=目录名    #增量备份时，指定上一次备份文件存储的目录名

先要有一次完全备份  存放目录 /fullbak
]# innobackupex  --user   root   --password  654321   \
--databases="gamedb  mysql  performance_schema  sys"  \
/fullbak  --no-timestamp

插入新记录，执行增量备份    存放目录 /new1bak
mysql> insert  into  gamedb.t1  values(8080),(8080);
]# innobackupex  --user   root   --password  654321   \
--databases="gamedb  mysql  performance_schema  sys"  \
--incremental    /new1dir    --incremental-basedir=/fullbak     --no-timestamp


插入新记录，执行增量备份    存放目录 /new2bak
mysql> insert  into  gamedb.t1  values(8099),(8099);
]# innobackupex  --user   root   --password  654321   \
--databases="gamedb  mysql  performance_schema  sys"  \
--incremental   /new2dir   --incremental-basedir=/new1dir   --no-timestamp


++++++++++++++增量恢复
--apply-log   准备恢复数据
--redo-only  合并日志
--incremental-dir=目录名   #增量恢复数据时，指定备份目录名称
--copy-back 恢复数据

清空数据库目录
]# rm   -rf   /var/lib/mysql
]# mkdir   /var/lib/mysql

准备恢复数据
]# innobackupex  --user   root   --password  654321   \
--databases="gamedb  mysql  performance_schema  sys"  \
--apply-log    --redo-only    /fullbak

合并日志
]# innobackupex  --user   root   --password  654321   \
--databases="gamedb  mysql  performance_schema  sys"  \
--apply-log    --redo-only    /fullbak   --incremental-dir=/new1dir

]# innobackupex  --user   root   --password  654321   \
--databases="gamedb  mysql  performance_schema  sys"  \
--apply-log    --redo-only    /fullbak   --incremental-dir=/new2dir


拷贝备份文件到数据库目录
]# innobackupex  --user   root   --password  654321   \
--databases="gamedb  mysql  performance_schema  sys"  \
--copy-back   /fullbak
]# ls  /var/lib/mysql   -l

修改文件的所有者/组mysql
]# chown  -R  mysql:mysql  /var/lib/mysql


重启数据库服务
]# systemctl   restart  mysqld
]# mysql   -uroot   -p654321


+++++++++++++++++++++使用完全备份文件恢复单个表
--export  导出表信息
mysql> alter  table  库.表   discard  tablespace;   删除表空间
mysql> alter  table  库.表  import  tablespace;  导入表空间

1完全备份
]#  innobackupex   --user   root    --password   654321   \
--databases="studb"    /allbakstudb    --no-timestamp

2查看备份目录文件列表
]# ls   /allbakstudb
]# ls   /allbakstudb/studb

3误删除a表:    mysql>  drop   table   studb.a;

4 使用完全备份文件恢复单个表
4.1  按照备份时的表结构创建删除的表
create   table  studb.a(name char(10));

4.2  删除创建表的表空间文件
mysql> alter  table studb.a  discard  tablespace; 

4.3  使用备份文件导出表信息
]#innobackupex --user root --password 654321   \
--databases="studb"  --apply-log   --export   /allbakstudb

4.4  把导出的表信息文件，拷贝到对应的数据库目录下，并修改所有者和组为mysql
]# cp /allbakstudb/studb/a.{cfg,exp,ibd}   /var/lib/mysql/studb/
]# chown mysql:mysql /var/lib/mysql/studb/a.*

4.5  导入表空间
mysql>  alter  table  studb.a  import  tablespace; 

[root@mysql51 ~]# rm  -rf /var/lib/mysql/studb/a.cfg 
[root@mysql51 ~]# rm  -rf /var/lib/mysql/studb/a.exp

4.6  查看记录
mysql> select   * from  studb.a;


mysql主从同步

角色分为2种：
数据库服务 做主master库：被客户端存储数据访问的库
数据库服务 做从slave库：同步主库的数据到本机

MySQL主从同步作用：实现数据的自动备份。


主

1 启用binlog日志
2 用户授权
3 查看正在使用的binlog日志信息


vim /etc/my.cnf
...
server_id=53
log-bin=master53
binlog-format="mixed"               //启用binlog日志


mysql>grant replication slave  on *.*  to repluser@"%" identified by '123456';    //授权一个用户来进行同步，也只有同步的权限

mysql>show master status ;     //查看bin-log日志的偏移量


mysql>grant all on bbsdb.* to jim@"%" identified by '123456';     //授权一个用户从客户端进行操作来验证
\

从

1 验证主库授权用户
2 指定server_id
3 指定主库信息
4 查看从库状态信息


 vim /etc/my.cnf
...
server_id=51    (一般写ip最后一个数)


mysql -uroot -p123456

添加主数据库的信息 
mysql> change master to 
master_host="192.168.4.52",       //主数据库的地址
master_user="repluser",           //授权同步的那个用户
master_password="123456",         //密码
master_log_file="master52.000001",     //主数据库的binlog
master_log_pos=451                //偏移量  




mysql> start slave;               //启动从  的线程   

mysql> show slave status ;  查看从库信息（属于谁的从库）	

            Slave_IO_Running: Yes
            Slave_SQL_Running: Yes       （这两个线程是   yes  说明从数据库配置成功）

mysql> show  processlist;   查看线程

工作原理
备库将主库的二进制日志复制到其本地的中继日志中。首先，备库会启动一个工作线程，称为I/O线程，I/O线程跟主库建立一个普通的客户端连接，然后在主库上启动一个特殊的二进制转存（Binglog Dump）线程，这个转存线程会读取主库上的二进制日志中事件，并发送给从库的I/O线程；如果主库没有更新信息将进入休眠。

[root@host52 ~]# cd /var/lib/mysql
master.info
relay-log.info
host52-relay-bin.xxxxxx
host52-relay-bin.index


IO线程：
Last_IO_Error:从主数据库的binlog日志中提取sql命令，放到从服务器的中继日志中

SQL线程
Last_SQL_Error:执行中继日志中的sql命令


http://github.com/yaya9998/notedir

如果添加主数据库的信息的时候有地方搞错了可以这样

stop  slave ;     停止这个线程（不停掉不让修改的）

change  master  to  master_log_pos=452;

start  slave; 


主从配置常用参数

主库  /etc/my.cnf
[mysqld]
#binlog_do_db=db2,bbsdb  只允许同步的库
binlog_ignore_db=db9   只不允许同步的库


从库/etc/my.cnf
[mysqld]
log_salve_updates 级联复制 ***        //应用在主从从     c是b的从，b是a的从，   修改了a后，b和c也会改变。
#replicate_do_db=db3,db5 只同步的库
replicate_ignore_db=db1,db7,db9 只不同步的库


三、主从同步模式
3.1 主从同步结构模式
一主一从 把52主机配置为51的从库 

一主多从 把50主机配置为51的从库 
从配置步骤：192.168.4.50
1 验证主库授权用户
2 指定server_id
3 指定主库信息
4 查看从库状态信息

主从从  把主机53配置为52从库。15:10

配置主库 192.168.4.52
启用binlog日志
用户授权

配置从库：192.168.4.53
1 验证主库授权用户
2 指定server_id
3 指定主库信息
4 查看从库状态信息
  
***
从库的SQL线程执行本机中继日志文件里的SQL命令，不会记

录在本机的binlog日志文件里。


复制模式

异步复制（Asynchronous replication）
MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。
 
全同步复制（Fully synchronous replication）
指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。
 
半同步复制（Semisynchronous replication）
介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。


查看是否支持动态加载模块
show variables like  "have_dynamic_loading";


查看以安装的插件
 SELECT  PLUGIN_NAME, PLUGIN_STATUS 
FROM INFORMATION_SCHEMA.PLUGINS  
WHERE PLUGIN_NAME LIKE '%semi%';

主库安装插件：
mysql>
INSTALL PLUGIN rpl_semi_sync_master SONAME  

'semisync_master.so';

从库安装插件：
mysql>
INSTALL PLUGIN rpl_semi_sync_slave SONAME 

'semisync_slave.so';



启用半同步复制
查看本机的半同步复制状态
show  variables  like  "rpl_semi_sync_%_enabled";
主库：
mysql>
 SET GLOBAL rpl_semi_sync_master_enabled = 1;

从库
mysql>
 SET GLOBAL rpl_semi_sync_slave_enabled = 1;





mysql调优

MySQL工作原理：
1.1 MySQL服务的工作过程

管理工具：MySQL服务软件安装后提供的命令
连接池：检查本机是否有资源处理当前的连接

请求                 （空闲的线程 内存）

sql接口：把sql命令传递给mysql服务的进程处理。

分析器：检查执行的sql命令是否有语法错误

优化器：优化执行的sql命令，使其能以最节省系统资源的方式执行。

查询缓存：查询缓存的存储空间是从系统的物理内存里划分出来的，用来存储查询过的查询结果。

存储引擎：软件自带的功能程序，是用来处理表的处理器。

文件系统 ： 数据库服务器存储数据的磁盘


MySQL优化：
数据库服务器处理客户的连接请求慢，可能是由哪些原因导致。
网络带宽
服务器硬件的配置：查看服务器硬件资源的使用情况 CPU  内存   存储  I/O

提供数据服务软件版本低。





mysql> show variables;       查看变量名

mysql> show variables like "%conn%";      //查看变量名像  conn

mysql> set global max_connections=500;     //设置最大连接数为500

mysql> show global status like "%conne%";  //查看当前已使用的连接数	




查看变量的值 
mysql> show  variables;
mysql> show  variables like "%关键字%";
mysql> show variables like "%time%";

帮助文档：
MySQL帮助手册
mysql配置文件详解

修改变量的值：
命令行修改
set  [global] 变量名=值；


永久修改
vim /etc/my.cnf
[mysqld]
变量名=值

常用的参数有哪些？
并发连接数
set global max_connections = 500;
show variables like "max_connections";

show  global status  like 

"%Max_used_connections%";

有过的最大连接数量/并发连接数=0.85
Max_used_connections/max_connections=0.8

5

100/x=0.85 *  100%  = 85%

可以重复使用的线程的数量
thread_cache_size  = 90 


为所有线程缓存打开表的数量
table_open_cache  2000 

mysqld  --->  t1.* ----> 内存 ---硬盘

key_buffer_size 索引缓存大小
index  primary key  foreign key

字段值排序 存储在 a.MYI /var/lib/mysql/a.ibd
select name from  user.a where name="bob";


查看数据库服务查询缓存的设置
show variables like "%cache%";

show variables like "query_cache%";


query_cache_type = 0 | 1 | 2

select  sql_in_cache  字段名列表from 表

；

query_cache_wlock_invalidate   off 

当对myisam存储引擎的表，查询的时候，若此时有客户端对表执行写操作，MySQL服务不会从缓存里查找数据返回给客户端，而是等写操作完成后，重新从表里查找数据返回给客户端。
atab    myisam
pc1  
select name from a where name="bob";

name="bob"  ----> 查询缓存

pc2 
select name from a where name="bob";


pc3
update  a  set  name="tom"  where 

name="bob";

查询缓存统计信息
Qcache_hits       10      
Qcache_inserts    100      


程序员编写的访问数据库服务数据的sql命令复杂 导致处理速度。

在数据库服务器上启用慢查询日志，记录超过指定时间显示查询结果的sql命令。

日志的种类：
binlog日志 错误日志 查询日志 慢查询日志 
              *



查询日志：记录所有的sql命令
启用日志  general-log
日志名    主机名.log
 
慢查询日志： 只记录超过超时时间(10s)显示查询结果的sql命令
vim /etc/my.cnf
[mysqld]
slow-query-log
log_queries_not_using_indexes=1
:wq

]# mysqldumpslow host10-slow.log


]# mysqldumpslow host10-slow.log  >  /root/sql.txt
vim  /root/sql.txt

数据存储架构问题：
数据传输时有瓶颈




MySQL数据读写分离
MySQL多实例
mysql性能优化

MySQL数据读写分离：
把客户端访问数据库服务时的查询请求和写数

据的请求给不同的数据库服务器处理。

人肉分离

就是让程序员查看数据的试试在一台mysql服务器上，写入数据的时候在另外一台数据库上




读写分离

部署MySQL数据读写分离架构
1 配置MySQL主从同步
要求：把20配置为10的从库。

配置主库10
启binlog日志
用户授权
查看日志信息

配置从库20
验证授权
指定server_id
指定主库信息
查看从库状态

客户端验证主从同步配置:
在主库添加访问数据的连接用户并设置密码
create database db12;
grant  all on  db12.*  to  yaya@"%" 

identified by "123qqq...A";

客户端连接主库 执行sql命令
mysql -h192.168.4.10 -uyaya -p123qqq...A
mysql> 建库 建表 插入记录

在从库本机也能够看到同样的数据
mysql  -uroot  -p123qqq...A
mysql> select  * from db12.a;


mysql中间件：mysql-proxy mycat  maxscale

在主机100上部署代理服务，实现数据读写分离。
装包
修改配置文件,并根据配置文件的设置在数据

库服务器上添加对应的授权用户。
启动服务。
查看服务信息。

]# rpm -ivh maxscale-2.1.2-1.rhel.7.x86_64.rpm

]# cp /etc/maxscale.cnf 

/etc/maxscale.cnf.bak



vim  /etc/maxscale.cnf
...

[server1] // 定义数据库服务器主机名
type=server
address=192.168.4.10 //master 主机 ip 地址
port=3306
protocol=MySQLBackend
[server2] // 定义数据库服务器
type=server
address=192.168.4.20 //slave 主机 ip 地址
port=3306
protocol=MySQLBackend

[MySQL Monitor] // 定义要监视的数据库服务器
type=monitor
module=mysqlmon
servers=server1, server2 // 定义的主、从数据库服务器主机名
user=scalemon // 用户名
passwd=111111 // 密码
monitor_interval=10000
[Read-Write Service] // 定义实现读写分离的数据库服务器
type=service
router=readwritesplit
servers=server1, server2 // 定义的主、从数据库服务器主机名
user=maxscale // 用户名
passwd=111111 // 密码
max_slave_connections=100%


在主、从数据库服务器创建授权用户

scalemon用户
grant replication slave, replication client on *.* to scalemon@'%'  identified by "123qqq...A";      //检查主从关系
 
maxscale用户
grant select on mysql.* to maxscale@'%'identified by "123qqq...A";                   //查看登陆的用户是否存在

select user from mysql.user where user in ("scalemon","maxscale");

mysql> grant all on *.* to student@'%' identified by “111111”; // 创建访问数据用户

#mysql -h192.168.4.10 -uscalemon -

p123qqq...A

#mysql -h192.168.4.20 -uscalemon -

p123qqq...A


 maxscale -f /etc/maxscale.cnf     //启动服务
 ps -C maxscale
 netstat -utnlp | grep maxscale


测试配置
1在主机100上连接管理服务查看监控信息
[root@host100 ~]# maxadmin -uadmin -pmariadb -P4099           //用户名密码默认是这样
MaxScale> list servers

2在客户端连接100主机，访问数据时能否实现

数据读写分离

]#ping  -c 2  192.168.4.100
]#which  mysql

]#mysql -h192.168.4.100 -P4006 -uyaya -p123qqq...A

进行查询和写的操作。
select    insert  



MySQL多实例  192.168.4.50

装包

定义命令路径
vim /etc/profile
export  PATH=/usr/local/mysql/bin:$PATH
:wq


创建配置文件
vim /etc/my.cnf
[mysqld_multi]
mysqld = /usr/local/mysql/bin/mysqld_safe
mysqladmin = /usr/local/mysql/bin/mysqladmin
user = root

[mysqld1]
port=3307
datadir=/dir3307
socket=/dir3307/mysqld3307.sock
pid-file=/dir3307/mysqld.pid
log-error=/dir3307/mysqld.err

[mysqld2]
port=3308
datadir=/dir3308
socket=/dir3308/mysqld3308.sock
pid-file=/dir3308/mysqld.pid
log-error=/dir3308/mysqld.err
:wq



创建数据库目录
mkdir /dir3307
mkdir /dir3308

初始授权库
]#mysqld  --user=mysql  --basedir=/usr/local/mysql --datadir=/dir3307 --initialize 


aLJJ#Dy76Wt3 登录初始密码

]# mysqld  --user=mysql  --basedir=/usr/local/mysql --datadir=/dir3307 --initialize 

2wtmOpI0Zp&Q  登录初始密码

启动实例服务
  617  mysqld_multi start 1
  618  netstat  -utnlp  | grep :3307

  619* mysqld_multi start 2
  620  netstat  -utnlp  | grep :3308

  621  ps -C mysqld
  624  netstat  -utnlp  | grep mysqld
  
  622  ps aux | grep mysqld

连接本机的数据库服务
]#mysql -uroot -p'初始密码'  -S  socket文件
mysql> alter user root@"localhost" identified by "123456";
mysql> quit

]#mysql -uroot -p123456  -S  socket文件
mysql> show databases;
mysql> 

停止指定的实例服务
]# mysqld_multi --user=root --password=密码  stop 实例编号 

# mysqld_multi --user=root --password=123456 stop 2
[root@host50 ~]# netstat  -utnlp  | grep ：3308

]# mysql -uroot -p123456 -S /dir3308/mysqld3308.sock 


change master to master_host="192.168.4.52",
master_user="repluser",
master_password="123456",
 master_log_file="master52.000010",
master_log_pos=154;


masterha_manager --conf=/etc/mha_manager/app1.cnf --remove_dead_master_conf  --ignore_last_failover

 change master to 
 master_host="192.168.4.51",
master_user="repluser",
 master_password="123456",
master_log_file="master51.000009",
 master_log_pos=154;











部署MySQL高可用集群 （MHA软件+主从同步）




集群 ： 使用多服务器提供相同的服务51-55

高可用集群 主备模式  当主角色的主机宕机后，备用主机自动接替主角色的主机，提供服务给客户端。

cilent  mysql  -h192.168.4.100  -uwebuser  -p123qqq...A

vip地址 192.168.4.100


                vip
  主       备用主  备用主           
mysql51  mysql52  mysql53    mysql54   mysql55
          slave    slave     slave     slave


准备MHA运行环境
一主多从
安装依赖的软件包
ssh root用户无密码登录

二、配置MHA


2.1 配置数据节点 192.168.4.51-55
2.1.1 一主多从 

2.1.2 安装依赖的perl软件包 

2.1.3 安装软件mha-node
yum -y  install perl-DBD-mysql
rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm 

2.1.4 彼此之间可以 ssh root用户无密码登录 

ssh-keygen
ssh-copy-id

2.1.5 授权监控用户 
grant all  on *.* to 'root'@'%' identified  by  "123456";
				     

2.1.6 所有数据库服务器启用不自动删除本机的中继日志文件
mysql> set global relay_log_purge=off;


2.2 配置管理主机 192.168.4.56：
2.2.1 安装依赖的perl软件包

2.2.2装包
]# yum -y  install perl-DBD-mysql 
]# rpm -ivh  mha4mysql-node-0.56-0.el6.noarch.rpm

]# yum -y  install perl-ExtUtils-*   perl-CPAN-*


]#tar -zxf mha4mysql-manager-0.56.tar.gz 

]#cd mha4mysql-manager-0.56
]# perl  Makefile.pl
]# make
]# make  install


2.2.3 指定命令所在的路径
]# cd mha4mysql-manager-0.56
]# mkdir /root/bin
]# cp bin/* /root/bin/
]# s /root/bin

2.2.4修改配置文件

]# mkdir /etc/mha_manager/
]# cd mha4mysql-manager-0.56/samples/conf/
]# cp  app1.cnf   /etc/mha_manager/

]# vim  /etc/mha_manager/app1.cnf

[server default]
manager_log=/etc/mha_manager/manager.log        //日志
manager_workdir=/etc/mha_manager                //工作目录
master_ip_failover_script=/etc/mha_manager/master_ip_failover     //调用的脚本
password=123456
repl_password=123456
repl_user=repluser
ssh_port=22
ssh_user=root
user=root

[server1]
candidate_master=1
hostname=192.168.4.51

[server3]
candidate_master=1
hostname=192.168.4.53

[server4]
hostname=192.168.4.54
no_master=1

[server5]
hostname=192.168.4.55
no_master=1



]# cd mha4mysql-manager-0.56/samples/scripts
]# cp master_ip_failover  /etc/mha_manager/

]# rm  -rf /etc/mha_manager/master_ip_failover 

]# cd  mha-soft-student
]# cp master_ip_failover /etc/mha_manager/

]# vim /etc/mha_manager/master_ip_failover 
 35 my $vip = '192.168.4.100/24';  # Virtual IP 
 36 my $key = "1";
 37 my $ssh_start_vip = "/sbin/ifconfig eth0:$key $vip";
 38 my $ssh_stop_vip = "/sbin/ifconfig eth0:$key down";


测试配置文件
 ]# vim /etc/mha_manager/app1.cnf
#master_ip_failover_script=/etc/mha_manager/master_ip_failover
:wq

]# masterha_check_ssh  --conf=/etc/mha_manager/app1.cnf

.... All SSH connection tests passed successfully.


]# masterha_check_repl --conf=/etc/mha_manager/app1.cnf
.....
.....
MySQL Replication Health is OK.


3 启动服务

3.1 把vip 地址手动绑定在当前的主库51上
]# ifconfig  eth0:1 192.168.4.100/24
]# ifconfig  eth0:1 

3.2 启动服务
]# vim /etc/mha_manager/app1.cnf
master_ip_failover_script=/etc/mha_manager/master_ip_failover
:wq


]#masterha_manager --conf=/etc/mha_manager/app1.cnf --remove_dead_master_conf  --

ignore_last_failover

]#masterha_check_status --conf=/etc/mha_manager/app1.cnf

4测试高可用集群配置

在数据库服务器上添加访问数据时连接用户 webuser  123qqq...A
mysql> create database db13;
Query OK, 1 row affected (0.04 sec)

mysql> grant all on  db13.* to webuser@"%" 
    -> identified by "123qqq...A";

4.1 客户端连接VIP地址访问数据库
]# mysql -h192.168.4.100 -uwebuser -p123qqq...A


4.2 测试高用集群
把主机51上的数据库服务停止 





把宕机的数据库服务器51 在添加到当前集群里


mysql> change master to master_host="192.168.4.52",
    -> master_user="repluser",
    -> master_password="123qqq...A",
    -> master_log_file="master52.000001",
    -> master_log_pos=154;
Query OK, 0 rows affected, 2 warnings (0.30 sec)

mysql> start slave;


56：
]# vim /etc/mha_manager/app1.cnf
[server1]
candidate_master=1
hostname=192.168.4.51

:wq

]# masterha_check_repl --conf=/etc/mha_manager/app1.cnf
MySQL Replication Health is OK.


]#masterha_manager --conf=/etc/mha_manager/app1.cnf --remove_dead_master_conf  --

ignore_last_failover


[root@mgm56 ~]# masterha_check_status --conf=/etc/mha_manager/app1.cnf
app1 (pid:8710) is running(0:PING_OK), master:192.168.4.52
[root@mgm56 ~]#





MySQL 视图

什么是视图 (View)
– 虚拟表
– 内容与真实的表相似,包含一系列带有名称的列和行
数据。
– 视图并不在数据库中以存储的数据的形式存在。
– 行和列的数据来自定义视图时查询所引用的基表,并
且在具体引用视图时动态生成。
– 更新视图的数据,就是更新基表的数据
– 更新基表数据,视图的数据也会跟着改变


建库，建表

create database db9;


create table user(
name char(20),
password char(1),
uid int(2),
gid int(2),
comment char(150),
homedir char(150),
shell char(30)
);


load data infile "/var/lib/mysql-files/passwd" into table user  fields terminated by ":"  lines terminated  by "\n";

导入文件到表中


alter table user
add id int(9)  primary key auto_increment first;     //添加id字段， 主键 ，自动增长。

use db9;

create view t1 as select name,shell from user where uid <=20;      //创建视图表   字段名和基表中的字段名  默认一样

show table status where comment="view"\G;      //查看哪些是视图表

show create view t1 ;                          //查看视图表是从哪个基表创建出来的


create view t2(user,stu_uid,stu_gid)  as select name,uid,gid from user limit 3 ;      (自定义视图表中的字段名，字段名的个数要和查出来的字段名的个数一样多) 

对视图表进行修改的话，基表也会被修改 ，  反之亦然。。

create view t3 as select id,name,shell,password  from user;


update t3 set name="tom" where id=1;

select name from t3 where id=1;

select name from user where id=1;



drop view t3;         //删除视图

insert into t3 values(77,"yaya","/etc/ss","F");

select * from t3 where id=77;

select * from user where id=77;


字段别名必须要写(多表查询)


create table user2  select name,uid,shell from user limit 5;


create table info  select name,uid,shell from user limit 10;

create view v2 as select a.name as aname,b.name as bname, a.uid as auid  b.uid as buid from user2 a left join  info  b on a.uid=b.uid;
                                                                                                                      //把user2起名为a     info起别名b  
                          

create view v2 
as 
select user2.name as uname, info.name as iname , user2.uid as uuid ,info.uid as iuid   
from  user2  left join  info  on user2.uid=info.uid;

//user2.name 别名 uname, info.name 起名 iname, user2.uid 起名 uuid ,info.uid 起名 iuid 



create  table user2 select name,uid,shell from user ;

select * from user2;


create view v1 as select * from user2 where uid<=30;

create view v2 as select * from v1 where uid >=20  with  check option;    //  默认是 CASCADED 同时要满足基表的限制。

show create view v2 

update v2 set uid=29 where name="mysql";      //要满足视图表和 基表

select * from v2 where name ="mysql";

select * from v1 where name ="mysql";

select * from  user2   where name ="mysql";


create  view v3 as select * from  v1 where uid>=20 with local check option；   //只需满足视图表的

select * from v3 ;

show create  view v3\G ;

update v3 set uid =35 where name="mysql";     //满足自己,可以查进去,如果不满足基表，可以插入进去，但是数据没有了



delimiter //
create procedure say1()
begin
select * from db9.user;
select * from  mysql.user where user="root";
end
//
delimiter ;

call say1;                    //调用

desc mysql.proc;               //存放存储过程


select db,name,type from mysql.proc where name="say1";


drop procedure say1;        删除存储方式



delimiter //
create procedure p1()
begin
select count(name) from user where shell="/bin/bash";
end
//
delimiter ;

call p1;


会话变量 会话变量和全局变量叫系统变量 使用 set 命令定义;
全局变量的修改会影响到整个服务器,但是对会
话变量的修改,只会影响到当前的会话。
全局变量
用户变量 在客户端连接到数据库服务的整个过程中都是有
效的。当当前连接断开后所有用户变量失效。
定义 set
@ 变量名 = 值;
输出 select @ 变量名;
局部变量 存储过程中的 begin/end 。其有效范围仅限于该
语句块中,语句块执行完毕后,变量失效。
declare 专门用来定义局部变量。
注意:局部变量 和 参数变量 调用时 变量名前不需要加 @



delimiter //
create procedure p2()
begin
declare x int default 77;      //定义局部变量，   仅在存储过程中有效
declare y char(10);
set y="yaya";                   //给局部变量赋值           （先定义在赋值）
select x;
select y;
end
//
delimiter ;

call p2;

show global variables;      //查看全局变量

show session variables;      //查看会话变量

set session sort_buffer_size=40000;     设置会话变量

show session variables like “sort_buffer_size”; // 查看会话变量

set @y = 3; // 用户自定义变量,直接赋值

select @y;

select max(uid) into @y from user; // 使用 sql 命令查询结果赋值(把user表中uid最大的赋值给y)


in 输入参数

delimiter //
create procedure p3(in username char(20))
begin
select name from user where name=username;
end
//
delimiter ;

call p3("yaya");      //有参数的存储过程，必须要传参。

out输出参数

delimiter //
create procedure p4(out num int(2))
begin
select num;
set num=7;
select num;
select count(name) into num from db9.user where shell="/bin/bash";
select num;
end
//
delimiter ;

set @x=7;
call p4();                      //把存储过程的输出的值赋给@x


inout  参数类型

delimiter //
create procedure p5(inout num int(2))
begin
select num;
set num=7;
select num;
select count(name) into num from db9.user where shell="/bin/bash";
select num;
end
//
delimiter ;

set @x=4;
call p5(@x);                    //既能接受又能输出，


if

delimiter //
create procedure p6(in num int(2))
begin
if num <= 10 then
	select * from db9.user where id <= num;
end if;

end
//
delimiter ;

 call p6(5) ;


if...else..

delimiter //
create procedure p7(in num int(2))
begin
if num is null then
	select * from db9.user where id = 2;
else
	select * from db9.user where id <= num;
end if;

end
//
delimiter ;


call p7(@num);      //空

set @num=3;

call p7(@num);     



while 

delimiter //
create procedure p8()
begin
	declare i int(2);
	set i=1;
	while i<=5 do
	select i;
	set i=i+1;
	end while;
end
//
delimiter ;


while  显示偶数行

delimiter //
create procedure p9()
begin
	declare i int(2);
	declare j int(2);
	select count(id) into i from user;	
	set j=1;
	
	while j <= i do
	if j % 2 = 0 then	
	select * from user where id=j;
	end if ;
	set j=j+1;
	end while;
end
//
delimiter ;


死循环

delimiter //
create procedure p10()
begin
	declare i int(2);
	set i=1;
	loop
	select i;
	set i=i+1;
	end loop;
end
//
delimiter ;




delimiter //
create procedure p11()
begin
	declare i int(2);
	set i=1;
	repeat
	select i;
	set i=i+1;
	until i=6           //满足条件跳出循环，不满足条件执行循环。
	end repeat;
end
//
delimiter ;



控制语句
• 循环结构控制语句,控制循环结构的执行。
– leave 标签名 //跳出循环
– iterate标签名 /放弃本次循环，执行下一次循环


mysql> create procedure say()
-> begin
-> declare i int;
-> set i=1;
-> loab1:loop //定义标签名为loab1
-> select i;
-> set i=i+1;
-> if i=3 then #i值是3时结束本次循环
-> iterate loab1;
-> end if;
-> if i=7 then #i值是7 时 结束循环
-> leave loab1;
-> end if;
-> end loop;
-> end





 create table employee(
 id int primary key,
 name varchar(100),
 age int(2),
sharding_id int not null
 );


insert into employee(id,name,age,sharding_id) values(1,"bob",21,10000),(2,"jim",22,10010);



 tar -xf redis-4.0.8.tar.gz 
cd redis-4.0.8/


make
 make install 
 ls 
cd utils/
ls
  ./install_server.sh 

ss -anptu | grep 6379


NOSQL

NoSQL  (Redis  MongoDB)

– 意思是 " 不仅仅是 SQL“
– 泛指非关系型数据库
– 不需要预先定义数据存储结构
– 表的每条记录都可以有不同的类型和结构



配置步骤：
1 装包
2 做初始化配置

3启动服务 (初始化配置完成后默认启动服务)
]# /etc/init.d/redis_6379 status | start | stop
]# netstat -utnlp  | grep :6379
]# ps -C redis-server

4 访问redis服务器存储数据
[root@host50 utils]# redis-cli 
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> set name bob       //设置字段
OK
127.0.0.1:6379> get name           //查看字段
"bob"
127.0.0.1:6379> quit
[root@host50 utils]# ls /var/lib/redis/6379/         //过段时间就会把nosql内存中的数据存到硬盘上（存数据库目录上）,假设中途服务器有宕机情况，内存中的数据也会强制写到硬盘上的（像memcache这种nosql是不会往硬盘上存的，如果宕机数据就没有了）
dump.rdb


常用操作指令
– Set keyname keyvalue // 存储
– get keyname // 获取
– Select 数据库编号 0-15 // 切换库
– Keys * // 打印所有变量
– Keys a? // 打印指定变量
– Exits keyname // 测试是否存在
// 查看生存时间
– ttl keyname
– type keyname // 查看类型

– move keyname dbname // 移动变量
– expire keyname 10 // 设置有效时间
// 删除变量
– del keyname
– flushall // 删除所有变量
– save // 保存变量     执行这个就是说直接把内存中的数据写到硬盘上
– shutdown // 关闭服务      //redis-cli  上关闭服务


常用配置选项    （修改配置文件中的字段   /etc/redis/6379.conf）

– port 6379 // 端口
– bind 127.0.0.1 //IP 地址
– tcp-backlog 511 //tcp 连接总数
– timeout 0 // 连接超时时间
– tcp-keepalive 300 // 长连接时间
– daemonize yes // 守护进程方式运行
– databases 16 // 数据库个数
– logfile /var/log/redis_6379.log //pid 文件
– maxclients 10000 // 并发连接数量
– dir /var/lib/redis/6379 // 数据库目录

内存管理
• 内存清除策略
– volatile-lru 最近最少使用 (针对设置了过期时间的 key )
– allkeys-lru 删除最少使用的 key
– volatile-random 在设置了过期的 key 里随机移除
– allkeys-random 随机移除 key
– volatile-ttl (minor TTL) 移除最近过期的 key
– noeviction 不删除 写满时报错

选项默认设置

– maxmemory <bytes> // 最大内存
– maxmemory-policy noeviction // 定义使用的策略
– maxmemory-samples 5 // 选取模板数据的个数
(针对 lru 和 ttl 策略)



设置连接密码


vim /etc/redis/6379.conf 
...
501 requirepass 123456        //添加密码字段


redis-cli  -h 192.168.4.50 -p 6350 -a 123456   //用密码连接到redis服务器

/etc/init.d/redis_6379  start     //启动

/etc/init.d/redis_6379  status    //状态

/etc/init.d/redis_6379  stop       //停止

ss -anptu | grep :6379

redis-cli  -h 192.168.4.50 -p 6350 -a 123456  shutdown    //停止服务


 vim /etc/init.d/redis_6379        //控制服务的状态的脚本
  
...
$CLIEXEC -h 192.168.4.50 -p $REDISPORT -a 123456 shutdown      // 增加密码字段

分析故障信息
– 设置 redis 主从后,连接主服务器需要密码
– 而 redis 启动脚本中未设置密码
• 分析故障原因
– redis 启动脚本通过执行 redis-cli -p 6379 shutdown
关闭 redis ,因此没有密码是无法关闭服务的
– 修改脚本 redis-cli -p 6379 -a 密码 shutdown


部署 LNMP+Redis



yum -y install gcc gcc-c++ pcre-devel zlib-devel
]# tar -zxf nginx-1.12.2.tar.gz	
]# cd nginx-1.12.2
]# ./configure --prefix=/usr/local/nginx
]# make
]# make install
[root@bogon ~ ]# yum -y install php-common
[root@bogon ~ ]# rpm -ivh php-fpm-5.4.16-42.el7.x86_64.rpm



修改 nginx 服务主配置文件 (打开9000端口的服务，用来解释php的脚本)

vim /usr/local/nginx/conf/nginx.conf
...
  
启动nginx   php-fpm  服务

测试文件  （编写测试php的文件，测试lnmp是否好使）

[root@bogon lnmp]# vim /usr/local/nginx/html/test.php
<?php
echo "hello world!!!";
?>
:wq


配置 PHP 支持 Redis

装包并启动服务

# tar -xzf redis-4.0.8.tar.gz
# cd redis-4.0.8
#make
#make install
#./utls/install_server.sh // 初始化redis服务（工作目录，日志文件。。。初始化完成后，服务就是开启的）
# /etc/init.d/redis_6379 start


安装 php 扩展  （可以让php连接redis数据库）

#yum -y install autoconf
#yum -y install automake
#rpm -ivh php-devel-5.4.16-42.el7.x86_64.rpm
# tar -zxf php-redis-2.2.4.tar.gz
# cd phpredis-2.2.4/
[root@bogon phpredis-2.2.4]# /usr/bin/phpize
Configuring for:
PHP Api Version:
20100412
Zend Module Api No:
20100525
Zend Extension Api No: 220100525
# ./configure --with-php-config=/usr/bin/php-config
[root@bogon phpredis-2.2.4]# make
[root@bogon phpredis-2.2.4]# make install
[root@bogon ~]# vim /etc/php.ini
extension_dir = "/usr/lib64/php/modules/"     //指定连接redis的程序所在位置
extension = "redis.so"

测试配置
• 查看是否支持模块
[root@bogon ~]# php -m | grep -i redis
redis



redis (nosql)集群


准备6台redis服务器，具体要求如下：
ip地址                 端口              etho                         日志文件名
192.168.4.51     6051            都可以接收连接请求   redis51.log
192.168.4.52     6052            都可以接收连接请求   redis52.log
192.168.4.53     6053            都可以接收连接请求   redis53.log
192.168.4.54     6054            都可以接收连接请求   redis54.log
192.168.4.55     6055            都可以接收连接请求   redis55.log
192.168.4.56     6056            都可以接收连接请求   redis56.log

环境准备
1  在6台redis服务器上运行服务，按照如下要求修改配置文件后，重启redis服务。

]#vim   /etc/redis/6379.conf
bind   192.168.4.56    #只指定物理接口ip地址
port    6056                 #不允许相同
daemonize yes
cluster-enabled  yes
pidfile /var/run/redis_56.pid    #不允许相同(可不设置)
cluster-config-file   nodes-6056.conf   #不允许相同
cluster-node-timeout 5000   #集群节点之间通信超时时间单位秒
:wq


 /etc/init.d/redis_6379 stop

 /etc/init.d/redis_6379 start

ss -anptu | grep 6056 

tcp    LISTEN     0      128    192.168.4.51:6351                  *:*                   users:(("redis-server",pid=20595,fd=6))
tcp    LISTEN     0      128    192.168.4.51:16351                 *:*                   users:(("redis-server",pid=20595,fd=8))
                                                          集群进行连接的端口


装包： 在执行创建集群命令的主机安装ruby软件包（192.168.4.51）

安装解释ruby代码的软件包
[root@host51 ~]# yum  -y  install   ruby   rubygems     
[root@host51 ~]# rpm  -q rubygems  ruby
rubygems-2.0.14.1-30.el7.noarch
ruby-2.0.0.648-30.el7.x86_64
[root@host51 ~]#

[root@host51 redis-cluster]# rpm  -ivh  --nodeps ruby-devel-2.0.0.648-30.el7.x86_64.rpm

安装ruby连接redis 接口程序 gem
[root@host51 redis-cluster]# which  gem
/usr/bin/gem
[root@host51 redis-cluster]# gem  install  redis-3.2.1.gem 
Successfully installed redis-3.2.1
Parsing documentation for redis-3.2.1
Installing ri documentation for redis-3.2.1
1 gem installed

生成创建集群的脚本redis-trib.rb

ls redis-4.0.8/src/redis-trib.rb 

[root@host51 src]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

[root@host51 src]# cd
[root@host51 ~]# cp redis-4.0.8/src/redis-trib.rb   /usr/local/bin/

创建集群：
[root@host51 ~]# redis-trib.rb  create   --replicas  1  \  
192.168.4.51:6051  \
192.168.4.52:6052   \
192.168.4.53:6053   \
192.168.4.54:6054   \
192.168.4.55:6055   \ 
192.168.4.56:6056

--replicas 1 表示 自动为每一个 master 节点分配一个 slave 节点

注意：搭建redis集群，至少是6台redis服务器，并且每一个redis数据库服务器下是没有任何内容的。

example

以下报错是有一个数据库的内容不是空的
[ERR] Node 192.168.4.54:6054 is not empty. Either the node already knows other nodes (check with 

CLUSTER NODES) or contains some key in database 0.

[root@db54 ~]# redis-cli  -h  192.168.4.54  -p  6054
192.168.4.54:6054> flushall
OK
192.168.4.54:6054> keys *
(empty list or set)
192.168.4.54:6054> flushall
OK
192.168.4.54:6054> save
OK
192.168.4.54:6054> quit
[root@db54 ~]#


redis 集群的工作原理

槽位个数是16384
范围0-16383

每一组主从服务器会有一个槽位的范围，当进行数据存储的时候，会对存储的字段进行计算，看计算出来的值是在哪个范围中的，就会存储到哪个里边，提取亦同。




[root@host51 ~]# redis-trib.rb  create   --replicas  1  192.168.4.51:6051  192.168.4.52:6052 

192.168.4.53:6053 192.168.4.54:6054 192.168.4.55:6055 192.168.4.56:6056   #创建集群
 --replicas  1    表示给master 配置1个slave






以下皆为创建集群的返回信息

>>> Creating cluster
>>> Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.4.51:6051
192.168.4.52:6052
192.168.4.53:6053
Adding replica 192.168.4.55:6055 to 192.168.4.51:6051
Adding replica 192.168.4.56:6056 to 192.168.4.52:6052
Adding replica 192.168.4.54:6054 to 192.168.4.53:6053
M: 0ec903c572270a90f3b140fba31aac15aaf5336b 192.168.4.51:6051
   slots:0-5460 (5461 slots) master
M: 5278df7384edc9774b1a36b0b9d60a813a7424a9 192.168.4.52:6052
   slots:5461-10922 (5462 slots) master
M: 6cdb4c64c48c0ee2ca35bf139660f31ca92821dc 192.168.4.53:6053
   slots:10923-16383 (5461 slots) master
S: 388c33e7128fc961b381ad3b3c27c3c217912666 192.168.4.54:6054
   replicates 6cdb4c64c48c0ee2ca35bf139660f31ca92821dc
S: 651f7d99965316c1b8a27a2e9b034a5b14c2be55 192.168.4.55:6055
   replicates 0ec903c572270a90f3b140fba31aac15aaf5336b
S: a3af3096ee214c92a178eadf6e9299584899e62f 192.168.4.56:6056
   replicates 5278df7384edc9774b1a36b0b9d60a813a7424a9
Can I set the above configuration? (type 'yes' to accept): yes
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join....
>>> Performing Cluster Check (using node 192.168.4.51:6051)
M: 0ec903c572270a90f3b140fba31aac15aaf5336b 192.168.4.51:6051
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
M: 388c33e7128fc961b381ad3b3c27c3c217912666 192.168.4.54:6054
   slots:9678 (1 slots) master
   0 additional replica(s)
S: 651f7d99965316c1b8a27a2e9b034a5b14c2be55 192.168.4.55:6055
   slots: (0 slots) slave
   replicates 0ec903c572270a90f3b140fba31aac15aaf5336b
S: a3af3096ee214c92a178eadf6e9299584899e62f 192.168.4.56:6056
   slots: (0 slots) slave
   replicates 5278df7384edc9774b1a36b0b9d60a813a7424a9
M: 6cdb4c64c48c0ee2ca35bf139660f31ca92821dc 192.168.4.53:6053
   slots:10923-16383 (5461 slots) master
   0 additional replica(s)
M: 5278df7384edc9774b1a36b0b9d60a813a7424a9 192.168.4.52:6052
   slots:5461-9677,9679-10922 (5461 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@host51 ~]# 


[root@db52 redis-4.0.8]# cat /var/lib/redis/6052/nodes-6052.conf   #集群配置文件
6cdb4c64c48c0ee2ca35bf139660f31ca92821dc 192.168.4.53:6053@16053 master - 0 1526096611374

3 connected 10923-16383
0ec903c572270a90f3b140fba31aac15aaf5336b 192.168.4.51:6051@16051 master - 0 1526096612000 

1 connected 0-5460
388c33e7128fc961b381ad3b3c27c3c217912666 192.168.4.54:6054@16054 master - 0 1526096611043 

4 connected 9678
a3af3096ee214c92a178eadf6e9299584899e62f 192.168.4.56:6056@16056 slave 

5278df7384edc9774b1a36b0b9d60a813a7424a9 0 1526096611745 6 connected
651f7d99965316c1b8a27a2e9b034a5b14c2be55 192.168.4.55:6055@16055 slave 

0ec903c572270a90f3b140fba31aac15aaf5336b 0 1526096613000 5 connected
5278df7384edc9774b1a36b0b9d60a813a7424a9 192.168.4.52:6052@16052 myself,master - 0 

1526096612000 2 connected 5461-9677 9679-10922
vars currentEpoch 6 lastVoteEpoch 0
[root@db52 redis-4.0.8]# 


 set the above configuration? (type 'yes' to accept): yes
/usr/local/share/gems/gems/redis-3.2.1/lib/redis/client.rb:113:in `call': ERR Slot 0 is already busy 

(Redis::CommandError)
	from /usr/local/share/gems/gems/redis-3.2.1/lib/redis.rb:2556:in `block in method_missing'
	from /usr/local/share/gems/gems/redis-3.2.1/lib/redis.rb:37:in `block in synchronize'
	from /usr/share/ruby/monitor.rb:211:in `mon_synchronize'
	from /usr/local/share/gems/gems/redis-3.2.1/lib/redis.rb:37:in `synchronize'
	from /usr/local/share/gems/gems/redis-3.2.1/lib/redis.rb:2555:in `method_missing'
	from /usr/local/bin/redis-trib.rb:212:in `flush_node_config'
	from /usr/local/bin/redis-trib.rb:906:in `block in flush_nodes_config'
	from /usr/local/bin/redis-trib.rb:905:in `each'
	from /usr/local/bin/redis-trib.rb:905:in `flush_nodes_config'
	from /usr/local/bin/redis-trib.rb:1426:in `create_cluster_cmd'
	from /usr/local/bin/redis-trib.rb:1830:in `<main>'
[root@mysql51 ~]# 




每台 redis服务 在本机登录 查看集群信息

[root@host51 ~]# redis-cli  -c -h 192.168.4.51  -p 6051 

-c  连接集群中的主机
[root@host51 ~]# redis-cli  -c -h 192.168.4.51  -p 6051 
192.168.4.51:6051> CLUSTER  info
192.168.4.51:6051> CLUSTER nodes
192.168.4.51:6051> quit


192.168.4.51:6051> CLUSTER nodes
388c33e7128fc961b381ad3b3c27c3c217912666 192.168.4.54:6054@16054 master - 0 1526108837942 

4 connected 9678
651f7d99965316c1b8a27a2e9b034a5b14c2be55 192.168.4.55:6055@16055 slave 

0ec903c572270a90f3b140fba31aac15aaf5336b 0 1526108838444 5 connected
a3af3096ee214c92a178eadf6e9299584899e62f 192.168.4.56:6056@16056 slave 

5278df7384edc9774b1a36b0b9d60a813a7424a9 0 1526108838946 6 connected
6cdb4c64c48c0ee2ca35bf139660f31ca92821dc 192.168.4.53:6053@16053 master - 0 1526108837942 

3 connected 10923-16383
0ec903c572270a90f3b140fba31aac15aaf5336b 192.168.4.51:6051@16051 myself,master - 0 

1526108836000 1 connected 0-5460
5278df7384edc9774b1a36b0b9d60a813a7424a9 192.168.4.52:6052@16052 master - 0 

1526108839447 2 connected 5461-9677 9679-10922
192.168.4.51:6051> 
192.168.4.51:6051> 
192.168.4.51:6051> 
192.168.4.51:6051> CLUSTER info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:4
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:26580
cluster_stats_messages_pong_sent:20656
cluster_stats_messages_update_sent:2
cluster_stats_messages_sent:47238
cluster_stats_messages_ping_received:20651
cluster_stats_messages_pong_received:26580
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:47236
192.168.4.51:6051> 






























